//! Generates TypeScript types and JSON messages from the ErrorCode enum.
//!
//! Run with: cargo run --bin generate-error-codes
//! Or via: make generate-error-codes

use scanopy::server::shared::types::error_codes::ErrorCode;
use std::collections::BTreeMap;
use std::fs;
use std::path::Path;
use strum::IntoEnumIterator;

fn main() {
    println!("Generating error codes...");

    // Collect all error codes with their metadata
    let codes: Vec<ErrorCodeInfo> = ErrorCode::iter()
        .map(|code| ErrorCodeInfo {
            code: code.code().to_string(),
            message: code.default_message().to_string(),
            params: extract_param_names(code.default_message()),
        })
        .collect();

    println!("Found {} error codes", codes.len());

    // Generate TypeScript file
    let ts_content = generate_typescript(&codes);
    let ts_path = Path::new("../ui/src/lib/generated/error-codes.ts");

    // Create directory if it doesn't exist
    if let Some(parent) = ts_path.parent() {
        fs::create_dir_all(parent).expect("Failed to create generated directory");
    }

    fs::write(ts_path, ts_content).expect("Failed to write TypeScript file");
    println!("Generated: {}", ts_path.display());

    // Generate JSON for merging into en.json
    let json_content = generate_messages_json(&codes);
    let json_path = Path::new("../ui/src/lib/generated/error-messages.json");
    fs::write(json_path, json_content).expect("Failed to write JSON file");
    println!("Generated: {}", json_path.display());

    println!("Done!");
}

#[derive(Debug)]
struct ErrorCodeInfo {
    code: String,
    message: String,
    params: Vec<String>,
}

/// Extract parameter names from a message template.
/// e.g., "Field '{field}' is required" -> ["field"]
fn extract_param_names(message: &str) -> Vec<String> {
    let mut params = Vec::new();
    let mut chars = message.chars().peekable();

    while let Some(c) = chars.next() {
        if c == '{' {
            let mut param_name = String::new();
            while let Some(&next) = chars.peek() {
                if next == '}' {
                    chars.next();
                    break;
                }
                param_name.push(chars.next().unwrap());
            }
            if !param_name.is_empty() {
                params.push(param_name);
            }
        }
    }

    params
}

fn generate_typescript(codes: &[ErrorCodeInfo]) -> String {
    let mut output = String::new();

    output.push_str("// Auto-generated by generate-error-codes. Do not edit.\n");
    output.push_str("// Run `make generate-types` to regenerate.\n\n");

    // ERROR_CODES constant
    output.push_str("export const ERROR_CODES = {\n");
    for info in codes {
        output.push_str(&format!(
            "  {}: \"{}\",\n",
            info.code,
            info.message.replace('\"', "\\\"")
        ));
    }
    output.push_str("} as const;\n\n");

    // ErrorCode type
    output.push_str("export type ErrorCode = keyof typeof ERROR_CODES;\n\n");

    // ErrorParams interface
    output.push_str("export interface ErrorParams {\n");
    for info in codes {
        if info.params.is_empty() {
            output.push_str(&format!("  {}: Record<string, never>;\n", info.code));
        } else {
            let params: Vec<String> = info
                .params
                .iter()
                .map(|p| format!("{}: string | number", p))
                .collect();
            output.push_str(&format!("  {}: {{ {} }};\n", info.code, params.join("; ")));
        }
    }
    output.push_str("}\n");

    output
}

fn generate_messages_json(codes: &[ErrorCodeInfo]) -> String {
    let messages: BTreeMap<String, String> = codes
        .iter()
        .map(|info| (format!("errors_{}", info.code), info.message.clone()))
        .collect();

    serde_json::to_string_pretty(&messages).expect("Failed to serialize messages")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_extract_param_names() {
        assert_eq!(
            extract_param_names("Field '{field}' is required"),
            vec!["field"]
        );
        assert_eq!(
            extract_param_names("{entity} with ID '{id}' not found"),
            vec!["entity", "id"]
        );
        assert_eq!(extract_param_names("No params here"), Vec::<String>::new());
    }
}
